# CHAPTER 16 Coroutines 第十六章 协程
*If Python books are any guide, [coroutines are] the most poorly documented, obscure, and apparently useless feature of Python. — David Beazley Python author*  
*如果Python这本书是本指南的话，而协程就是最缺少文档、而又鲜为人知，似乎很无用的Python的一个功能。-Python作者David Beazley*  

We find two main senses for the verb “to yield” in dictionaries: to produce or to give way. Both senses apply in Python when we use the yield keyword in a generator. A line such as yield item produces a value that is received by the caller of next(...), and it also gives way, suspending the execution of the generator so that the caller may proceed until it’s ready to consume another value by invoking next() again. The caller pulls values from the generator.  
我们在字典中发现动词“to yield”的两个主要含义：产生（produce）或者让步（give way）。这两个含义都可以在我们需要在生成器中使用yield关键字时在Python中运用。诸如yield元素的一行，既会产生（produce）一个供next()调用者接收的值，也会让步（give way）:暂停generator的执行以便于调用者可能的操作，直到他准备好通过再一次调用next()来消费另一个值。调用者通过generator来取值。

A coroutine is syntactically like a generator: just a function with the yield keyword in its body. However, in a coroutine, yield usually appears on the right side of an expression (e.g., datum = yield), and it may or may not produce a value—if there is no expression after the yield keyword, the generator yields None. The coroutine may receive data from the caller, which uses .send(datum) instead of next(...) to feed the coroutine. Usually, the caller pushes values into the coroutine.  
一个协程在语法上类似生成器：仅仅是一个函数体中包含了yield关键词。但是在协程中，yield通常出现在表达式的右侧（如 datum = yield），并且yield可能产生值也可能不产生——如果在yield后没有表达式的话，生成器会产生None。
协程可以从调用者方接收数据，用.send(datum)而不是next()用于提供给协程。通常，调用者会推送值到协程中

It is even possible that no data goes in or out through the yield keyword. Regardless of the flow of data, yield is a control flow device that can be used to implement cooperative multitasking: each coroutine yields control to a central scheduler so that other coroutines can be activated.  
甚至可能没有数据从yield关键词进出。不管数据流如何，yield是一个可以被用于完成协同多任务的控制流设备：每一条协程将控制器交给（yield）一个中央调度器 以便其余协程可以被激活。

When you start thinking of yield primarily in terms of control flow, you have the mindset to understand coroutines.  
当你开始首先从控制流角度考虑yield，你就有了理解协程的思维方式。

Python coroutines are the product of a series of enhancements to the humble generator functions we’ve seen so far in the book. Following the evolution of coroutines in Python helps understand their features in stages of increasing functionality and complexity.  
Python协程是对简陋的生成器函数（我们已经在书中见过）进行一系列加强的产物。跟随着协程在Python中的发展，这有助于理解他们在增加功能性与复杂性阶段的特性。

After a brief overview of how generators were enable to act as a coroutine, we jump to the core of the chapter. Then we’ll see:  
在一个生成器如何能够充当协程的简短概要之后，我们走进了本章的核心。接下来我们可以看到：  

- The behavior and states of a generator operating as a coroutine
- Priming a coroutine automatically with a decorator
- How the caller can control a coroutine through the .close() and .throw(...) methods of the generator object
- How coroutines can return values upon termination
- Usage and semantics of the new yield from syntax
- A use case: coroutines for managing concurrent activities in a simulation
- 作为协程运行的生成器的行为和状态
- 使用装饰器自动启动一个协程
- 调用者是如何通过生成器对象中的.close()和.throw(...)方法控制一个协程的
- 协程是如何在终止前return值的
- 用例：在模拟环境中用协程管理并发动作


## How Coroutines Evolved from Generators
## 协程是如何从生成器进化而来的

The infrastructure for coroutines appeared in PEP 342 — Coroutines via Enhanced Generators, implemented in Python 2.5 (2006): since then, the yield keyword can be used in an expression, and the .send(value) method was added to the generator API. Using .send(...), the caller of the generator can post data that then becomes the value of the yield expression inside the generator function. This allows a generator to be used as a coroutine: a procedure that collaborates with the caller, yielding and receiving values from the caller.  
协程的基础架构出现在PEP 342——通过加强生成器的协程，在Python 2.5(2006)实现：从那时起，yield关键词可以被用于在一个表达式中，并且.send(value)方法被加入至生成器API。
使用.send(...)，生成器的调用者可以post数据，这些数据随后成为生成器func中yield表达式的值。这允许一个生成器被用作一个协程：和调用者合作的过程，从调用者方yield与receive值。

In addition to .send(...), PEP 342 also added .throw(...) and .close() methods that respectively allow the caller to throw an exception to be handled inside the generator, and to terminate it. These features are covered in the next section and in “Coroutine Termination and Exception Handling” on page 471.  
除.send(...)以外，PEP 342还增加了.throw(...)和.close()方法，分别允许调用者抛出在生成器内部处理的异常与终止他。下一节与471页上的“协程终止与异常处理”会介绍这些特点

The latest evolutionary step for coroutines came with PEP 380 - Syntax for Delegating to a Subgenerator, implemented in Python 3.3 (2012). PEP 380 made two syntax changes to generator functions, to make them more useful as coroutines:  
协程的最新进化步骤来自PEP 380——委托给子生成器的语法，实现于Python3.3(2012)。PEP 380对生成器函数做了两处语法变动，使得他们作为协程时更加有用。

- A generator can now return a value; previously, providing a value to the return statement inside a generator raised a SyntaxError.
- The yield from syntax enables complex generators to be refactored into smaller, nested generators while avoiding a lot of boilerplate code previously required for a generator to delegate to subgenerators.
- 生成器现在可以返回一个值；在以前，提供在生成器内部向返回语句提供值会引发SyntaxError。
- 语法中的yield允许复杂的生成器被重构到更加精简，嵌套生成器，同时避免生成器以前需要许多样板代码委托给子生成器。

These latest changes will be addressed in “Returning a Value from a Coroutine” on page 475 and “Using yield from” on page 477.  
最新的变化将会在475页的“从协程返回值”和477页的“使用yield from”

Let’s follow the established tradition of Fluent Python and start with some very basic facts and examples, then move into increasingly mind-bending features.  
让我们遵循Fluent Python所建立的传统，从一些非常基础的实例开始，然后一步步接近那些越来越多的令人费解的特点。


## Basic Behavior of a Generator Used as a Coroutine
## 用作协程的生成器的基础行为

Example 16-1 illustrates the behavior of a coroutine.
Example 16-1 阐明协程的行为。  

Example 16-1. Simplest possible demonstration of coroutine in action  
Example 16-1. 有关协程运行的最简单的demo

```python
>>> def simple_coroutine(): # 1
...     print('-> coroutine started')
...     x = yield # 2
...     print('-> coroutine received:', x)
...
>>> my_coro = simple_coroutine()
>>> my_coro # 3
<generator object simple_coroutine at 0x100c2be10> 
>>> next(my_coro) # 4
-> coroutine started
>>> my_coro.send(42) # 5
-> coroutine received: 42
Traceback (most recent call last): # 6
    ...
    StopIteration
```

1. A coroutine is defined as a generator function: with yield in its body.
1. 协程被作为一个生成器方法进行定义：通过他体内的yield关键词。

2. yield is used in an expression; when the coroutine is designed just to receive data from the client it yields None—this is implicit because there is no expression to the right of the yield keyword. 
2. yield在表达式中使用；当该协程被设计为只从client接收数据时，他会产生None——这是隐含的，因为yield右侧没有表达式。

3. As usual with generators, you call the function to get a generator object back. 
3. 和生成器一样，你调用这个函数用于取回一个生成器对象。
 
4. The first call is next(...) because the generator hasn’t started so it’s not waiting in a yield and we can’t send it any data initially. 
4. 第一次调用是next(...)因为该生成器还没有开始，所以他没有在yield中等待——我们不能在初始化时send他任何数据。

5. This call makes the yield in the coroutine body evaluate to 42; now the coroutine resumes and runs until the next yield or termination.
5. 这次调用使得协程体内的yield evaluate to 42；现在该协程重新开始并运行直到下一次yield或终止。

6. In this case, control flows off the end of the coroutine body, which prompts the generator machinery to raise StopIteration, as usual.  
6. 在该case中，控制流在协程体的末尾后关闭，促使生成器与往常一样抛出StopIteration

A coroutine can be in one of four states. You can determine the current state using the inspect.getgeneratorstate(...) function, which returns one of these strings:  
协程可以是这四种状态之一。你可以使用inspect.getgeneratorstate(...)方法来决定当前状态，该方法返回下列strings中之一。

'GEN_CREATED'
    Waiting to start execution.
    等待开始执行。
'GEN_RUNNING'
    Currently being executed by the interpreter.[1]
    当前正在被解释器执行。
'GEN_SUSPENDED'
    Currently suspended at a yield expression.
    当前在yield表达式中暂停。
'GEN_CLOSED'
    Execution has completed.
    执行结束。
[1. You’ll only see this state in a multithreaded application—or if the generator object calls getgenerator state on itself, which is not useful.]
[1. 你只会在多线程应用看到这个状态，或者如果生成器对象在自身调用getgeneratorstate方法，不过这没什么用。]


Because the argument to the send method will become the value of the pending yield expression, it follows that you can only make a call like my_coro.send(42) if the coroutine is currently suspended. But that’s not the case if the coroutine has never been activated—when its state is 'GEN_CREATED'. That’s why the first activation of a coroutine is always done with next(my_coro)—you can also call my_coro.send(None), and the effect is the same.  
因为send方法的参数将成为暂停的yield表达式的值，于是如果在协程处于暂停状态时 你才能做my_coro.send(42)这样的调用。不过 如果协程还未激活（他处于'GEN_CREATED'状态时）情况就不同了。这也是为什么对协程的第一次操作总是使用next(my_coro)，或是使用my_coro.send(None)是一样的效果。

If you create a coroutine object and immediately try to send it a value that is not None, this is what happens:  
如果你创建了一个协程对象，并且立刻尝试send给他一个不为None的值，会出现如下：

```
>>> my_coro = simple_coroutine() 
>>> my_coro.send(1729)
Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    TypeError: can't send non-None value to a just-started generator
```

Note the error message: it’s quite clear.  
注意这个error信息：他描述得十分清楚。

The initial call next(my_coro) is often described as “priming” the coroutine (i.e., advancing it to the first yield to make it ready for use as a live coroutine).  
最先调用next(my_coro)通常被描述为“预先激活”协程（即，推进他到第一个yield表达式，使得他作为一个live的协程）

To get a better feel for the behavior of a coroutine, an example that yields more than once is useful. See Example 16-2.  
为了更好地理解协程的这个行为，一个yield多个值的例子更加直观。如示例16-2

*Example 16-2. A coroutine that yields twice*  
*示例 16-2 产出两个值的协程*

```python
>>> def simple_coro2(a):
...     print('-> Started: a =', a)
...     b = yield a
...     print('-> Received: b =', b)
...     c = yield a + b
...     print('-> Received: c =', c)
...
>>> my_coro2 = simple_coro2(14)
>>> from inspect import getgeneratorstate 
>>> getgeneratorstate(my_coro2) # 1
'GEN_CREATED'
>>> next(my_coro2) # 2
-> Started: a = 14
14
>>> getgeneratorstate(my_coro2)  # 3
'GEN_SUSPENDED'
>>> my_coro2.send(28) # 4
-> Received: b = 28
42
>>> my_coro2.send(99) # 5
-> Received: c = 99
Traceback (most recent call last):
    File "<stdin>", line 1, in <module> StopIteration
>>> getgeneratorstate(my_coro2)  # 6
'GEN_CLOSED'
```

1. inspect.getgeneratorstate reports `GEN_CREATED` (i.e., the coroutine has not started).
1. inspect.getgeneratorstate指明，处于GEN_CREATED状态（即该协程未启动）

2. Advance coroutine to first yield, printing `-> Started: a = 14` message then yielding value of a and suspending to wait for value to be assigned to b.
2. 推动协程到第一个yield，print “Started : a = 14”的信息，然后产出a的值，暂停并等待值来为b赋值。

3. getgeneratorstate reports `GEN_SUSPENDED` (i.e., the coroutine is paused at a yield expression).
3. getgeneratorstate指明GEN_SUSPENDED状态（即协程在yield表达式处暂停）

4. Send number 28 to suspended coroutine; the yield expression evaluates to 28 and that number is bound to b. The `-> Received: b = 28` message is displayed, the value of a + b is yielded (42), and the coroutine is suspended waiting for the value to be assigned to c.
4. send数字28到暂停的协程；yield表达式得到28，然后把这个数字绑定给b。显示"-> Received: b = 28"信息，然后yield a + b的值（42），然后协程暂停等待值准备赋给c

5. Send number 99 to suspended coroutine; the yield expression evaluates to 99 the number is bound to c. The `-> Received: c = 99 message` is displayed, then the coroutine terminates, causing the generator object to raise StopIteration.
5. send数字99到暂停的协程；yield表达式得到99，然后把这个数字绑定给c。显示""信息，然后协程终止，导致生成器抛出StopIteration。

6. getgeneratorstate reports `GEN_CLOSED` (i.e., the coroutine execution has completed).
6. getgeneratorstate指明GEN_CLOSED状态（即协程执行完成）


It’s crucial to understand that the execution of the coroutine is suspended exactly at the yield keyword. As mentioned before, in an assignment statement, the code to the right of the = is evaluated before the actual assignment happens. This means that in a line like b = yield a, the value of b will only be set when the coroutine is activated later by the client code. It takes some effort to get used to this fact, but understanding it is essential to make sense of the use of yield in asynchronous programming, as we’ll see later.

理解"协程的执行恰好在yield关键词位置暂停"是很重要的。如上所述，在赋值语句中，"="右侧的代码在实际赋值前被执行。这意味着在类似"b = yield a"的语句中，只有当协程被client code激活后才会为b赋值。习惯于这个事情需要一些努力，但是对于搞清楚异步编程中yield的用法来讲，这是必不可少的。

Execution of the simple_coro2 coroutine can be split in three phases, as shown in Figure 16-1:
如图表16-1所示，协程simple_coro2的执行可以分割到三个阶段：

1. `next(my_coro2)` prints first message and runs to yield a, yielding number 14.
    `next(my_coro2)`打印第一条信息，并且运行至yield a，产出数字14
2. `my_coro2.send(28)` assigns 28 to b, prints second message, and runs to `yield a + b`, yielding number 42.
    `my_coro2.send(28)`将28赋值给b，打印第二条信息，并且运行至yield a + b，产出数字42
3. `my_coro2.send(99)` assigns 99 to c, prints third message, and the coroutine terminates.
    `my_coro2.send(99)`将99赋值给c，打印第三条信息，然后协程终止

![image](c16_1.png)

Figure 16-1. Three phases in the execution of the simple_coro2 coroutine (note that each phase ends in a yield expression, and the next phase starts in the very same line, when the value of the yield expression is assigned to a variable)
图表16-1. 协程simple_coro2

Now let’s consider a slightly more involved coroutine example.
现在，我们来思考一个稍微深入一些的协程示例。

## Example: Coroutine to Compute a Running Average
While discussing closures in Chapter 7, we studied objects to compute a running average: Example 7-8 shows a plain class and Example 7-14 presents a higher-order function producing a closure to keep the total and count variables across invocations. Example 16-3 shows how to do the same with a coroutine.[2]

在第七章讨论闭包时，我们学习了计算运行平均时间的主题：例子7-8显示的一个普通类，例子7-14展示了一个产生必包并保存

[注释2]2. This example is inspired by a snippet from Jacob Holm in the Python-ideas list, message titled “Yield-From: Finalization guarantees.” Some variations appear later in the thread, and Holm further explains his thinking in message 003912.

【注释2】

Example 16-3. coroaverager0.py: code for a running average coroutine

例子16-3. coroaverager0.py：运行平均数的协程代码。

```python
def averager(): 
    total = 0.0
    count = 0 
    average = None 
    while True: #1
        term = yield average #2
        total += term 
        count += 1
        average = total/count
```

1. This infinite loop means this coroutine will keep on accepting values and producing results as long as the caller sends them. This coroutine will only terminate when the caller calls .close() on it, or when it’s garbage collected because there are no more references to it.
    这个无限循环意味着，只要调用者send他，这个协程将保持接收value并产出result。只有当调用者使用.close()或者他被作为垃圾收集（因为没有更多引用）时，这个协程才会被终止。
2. The yield statement here is used to suspend the coroutine, produce a result to the caller, and—later—to get a value sent by the caller to the coroutine, which resumes its infinite loop.
    yield语句在这里被用于暂停协程，为调用者生成result，并且不断地从调用者那里获取value

The advantage of using a coroutine is that total and count can be simple local variables: no instance attributes or closures are needed to keep the context between calls. Example 16-4 are doctests to show the averager coroutine in operation.
使用协程的优势在于——total和count可以是简单的local变量：不需要实例属性或闭包来保持调用之间的上下文。Example 16-4通过实际操作来展示averager协程。

Example 16-4. coroaverager0.py: doctest for the running average coroutine in Example 16-3
例子16-4. coroaverager0.py：对例子16-3中的运行平均协程的doctest。

```python
>>> coro_avg = averager()
>>> next(coro_avg)
>>> coro_avg.send(10)
10.0
>>> coro_avg.send(30)
20.0
>>> coro_avg.send(5)
15.0
```

1. Create the coroutine object.
    创建协程对象。
2. Prime it by calling next.
    让协程为next调用做好准备。
3. Now we are in business: each call to .send(...) yields the current average.
    现在我们已经就绪：每次对于send的调用都生成当前的值。

In the doctest (Example 16-4), the call next(coro_avg) makes the coroutine advance to the yield, yielding the initial value for average, which is None, so it does not appear on the console. At this point, the coroutine is suspended at the yield, waiting for a value to be sent. The line `coro_avg.send(10)` provides that value, causing the coroutine to activate, assigning it to term, updating the total, count, and average variables, and then starting another iteration in the while loop, which yields the average and waits for another term.
在这个例子中，调用next(coro_avg)使得协程推进至yield，yield初始值为None所以不会显示。此时，协程暂停于yield，等待一个被send的value。`coro_avg.send(10)`这一行提供了该值，导致协程被激活，分配这个值到语句中，更新了total count/average变量，然后开始了循环的下一次迭代，知道yield出average并等待下一项。

The attentive reader may be anxious to know how the execution of an averager instance (e.g., coro_avg) may be terminated, because its body is an infinite loop. We’ll cover that in “Coroutine Termination and Exception Handling” on page 471.
细心的读者可能渴望了解averager实例的执行是如何被终止的，因为他是一个无限循环的执行体。我们将在471页的“协程终止与异常处理”来解释

But before discussing coroutine termination, let’s talk about getting them started. Priming a coroutine before use is a necessary but easy-to-forget chore. To avoid it, a special decorator can be applied to the coroutine. One such decorator is presented next.
但是在我们讨论协程终止之前，我们来说说如何启动它。在使用前启动协程是必要的，但这是很容易忘记的任务。

## Decorators for Coroutine Priming 装饰器对于协程准备上的使用

You can’t do much with a coroutine without priming it: we must always remember to call next(my_coro) before my_coro.send(x). To make coroutine usage more convenient, a priming decorator is sometimes used. The coroutine decorator in Example 16-5 is an example.[3]

你无法使用一个没有准备好的协程：我们必须总得记得在执行my_coro.send(x)之前调用next(my_coro)。为了让协程使用起来更方便，我们有时候使用priming decorator。

[注释3]There are several similar decorators published on the Web. This one is adapted from the ActiveState recipe Pipeline made of coroutines by Chaobin Tang, who in turn credits David Beazley.

【注释3】有多个类似的装饰器公布在网上。

Example 16-5. coroutil.py: decorator for priming coroutine

例子16-5.

```python
from functools import wraps


def coroutine(func):
    """Decorator: primes `func` by advancing to first `yield`"""
    @wraps(func)
    def primer(*args,**kwargs): #1
        gen = func(*args,**kwargs) #2
        next(gen) #3
        return gen #4
    return primer
```

1. The decorated generator function is replaced by this primer function which, when invoked, returns the primed generator.
    装饰生成器的函数被这个基本的函数替换，在其被调用时，返回原始装饰器。
2. Call the decorated function to get a generator object.
    调用被装饰的函数以获取生成器对象。
3. Prime the generator.
    原始装饰器。
4. Return it.
    返回生成器。

Example 16-6 shows the @coroutine decorator in use. Contrast with Example 16-3. 

例子16-6 展示了装饰器@coroutine的使用。对标例子16-3.

Example 16-6. coroaverager1.py: doctest and code for a running average coroutine us‐
ing the @coroutine decorator from Example 16-5

例子16-6. coroaverager1.py:

```python
"""
A coroutine to compute a running average
    >>> coro_avg = averager()       #1
    >>> from inspect import getgeneratorstate
    >>> getgeneratorstate(coro_avg) #2
    'GEN_SUSPENDED'
    >>> coro_avg.send(10)   #3
    10.0
    >>> coro_avg.send(30)
    20.0
    >>> coro_avg.send(5)
    15.0
"""
from coroutil import coroutine  #4

@coroutine #5
def averager():
    total = 0.0
    count = 0
    average = None
    while True:
        term = yield average
        total += term
        count += 1
        average = total/count
```

1. Call averager(), creating a generator object that is primed inside the primer function of the coroutine decorator.
    调用averager()，创建一个生成器对象，该对象已经被coroutine装饰器的primer函数激活。
2. getgeneratorstate reports GEN_SUSPENDED, meaning that the coroutine is ready to receive a value.
    getgeneratorstate记录为GEN_SUSPENDED状态，意味该协程已经准备好接受value。
3. You can immediately start sending values to coro_avg: that’s the point of the decorator.
    你可以立刻开始传送value至coro_avg：这就是装饰器的意义所在。
4. Import the coroutine decorator.
    引入协程装饰器。
5. Apply it to the averager function.
    应用至average函数上。
6. The body of the function is exactly the same as Example 16-3.
    该函数的结构类似Example 16-3。

Several frameworks provide special decorators designed to work with coroutines. Not all of them actually prime the coroutine—some provide other services, such as hooking it to an event loop. One example from the Tornado asynchronous networking library is the tornado.gen decorator.
一些框架提供了特定装饰器——为协程而设计。不是所有都会启动协程——一些装饰器提供其他的服务，诸如“连接一个event loop”。以Tornado的异步networking库 tornado.gen装饰器举例。

The yield from syntax we’ll see in “Using yield from” on page 477 automatically primes the coroutine called by it, making it incompatible with decorators such as @coroutine from Example 16-5. The asyncio.coroutine decorator from the Python 3.4 standard library is designed to work with yield from so it does not prime the coroutine. We’ll cover it in Chapter 18.
We’ll now focus on essential features of coroutines: the methods used to terminate and throw exceptions into them.
我们将在477页的“使用yield from”介绍yield from的语法，通过使用这个会自动启动协程，使他与装饰器不兼容，如Example16-5中@coroutine。Python3.4标准库中的asyncio.corotine装饰器被定义为通过yield from运作，所以他不会启动协程。我们将在18节讨论他。
我们现在专注于协程中非常重要的特点：用于终止或抛出异常的方法。

## Coroutine Termination and Exception Handling
## 协程终止与异常处理

An unhandled exception within a coroutine propagates to the caller of the next or send that triggered it. Example 16-7 is an example using the decorated averager coroutine from Example 16-6.
一个协程中未处理的异常会传播到触发了next或send的调用者。Example 16-7是一个使用装饰averager协程的示例。

Example 16-7. How an unhandled exception kills a coroutine
示例16-7，未处理异常是如何杀掉协程的

```python
>>> from coroaverager1 import averager 
>>> coro_avg = averager()
>>> coro_avg.send(40) #1
40.0
>>> coro_avg.send(50)
45.0
>>> coro_avg.send('spam') #2
Traceback (most recent call last):
  ...
TypeError: unsupported operand type(s) for +=: 'float' and 'str' 
>>> coro_avg.send(60) #3
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
```

1. Using the @coroutine decorated averager we can immediately start sending values.
    使用@coroutine装饰过的averager，我们可以立刻开始send value
2. Sending a nonnumeric value causes an exception inside the coroutine. 
    send一个非数字类型的value导致协程内部异常
3. Because the exception was not handled in the coroutine, it terminated. Any attempt to reactivate it will raise StopIteration.
    因为协程内的异常未经过处理即终止，任何企图重新激活他的操作将会抛出StopIteration

The cause of the error was the sending of a value 'spam' that could not be added to the total variable in the coroutine.
该error的原因在于send了"spam"，在协程中这不能被累加到total变量。

Example 16-7 suggests one way of terminating coroutines: you can use send with some sentinel value that tells the coroutine to exit. Constant built-in singletons like None and Ellipsis are convenient sentinel values. Ellipsis has the advantage of being quite unusual in data streams. Another sentinel value I’ve seen used is StopIteration—the class itself, not an instance of it (and not raising it). In other words, using it like: my_coro.send(StopIteration).
例16-7侧面表现出终止协程的一种方式：你可以通过send一些标记值来通知协程退出。singletons中内建常量，如None和Ellipsis是很便利的标记值。Ellipsis拥有在数据流中成为“异端”的优点。另一个标记值，我见过使用到的是StopIteration——类本身，而不是他的实例（也不抛出他）。换句话说，像这样用：my_coro.send(StopIteration)。

Since Python 2.5, generator objects have two methods that allow the client to explicitly send exceptions into the coroutine—throw and close:
从Python2.5起，生成器对象都拥有两个方法，允许client端去直接发送异常到协程内部，即throw和close

- generator.throw(exc_type[, exc_value[, traceback]])
    Causes the yield expression where the generator was paused to raise the exception given. If the exception is handled by the generator, flow advances to the next yield, and the value yielded becomes the value of the generator.throw call. If the exception is not handled by the generator, it propagates to the context of the caller.
    导致在生成器在暂停的yield表达式去引发给定的异常。如果该异常被生成器处理，数据流将推动至下一个yield，然后产出的值。如果会成为调用.throw的返回值。该异常没有被生成器处理，将传递到调用者的上下文中。

- generator.close()
    Causes the yield expression where the generator was paused to raise a Generator Exit exception. No error is reported to the caller if the generator does not handle that exception or raises StopIteration—usually by running to completion. When receiving a GeneratorExit, the generator must not yield a value, otherwise a Run timeError is raised. If any other exception is raised by the generator, it propagates to the caller.
    导致生成器在暂停的yield表达式处引发一个Generator Exit异常。如果生成器没有处理这个异常，或抛出StopIteration（通常是指运行至结尾），调用者不会受到任何错误信息。当接收到GeneratorExit时，生成器一定不会产出值，否则将会抛出RuntimeError。如果生成器抛出任何其他的异常，将传递至调用者处。

>###Note
>The official documentation of the generator object methods is buried deep in The Python Language Reference, (see 6.2.9.1. Generator-iterator methods).

Let’s see how close and throw control a coroutine. Example 16-8 lists the demo_exc_han dling function used in the following examples.
让我们看看close和throw如何控制协程的。Example 16-8列出了接下来的例子是用的demo_exc_handing函数

Example 16-8. coro_exc_demo.py: test code for studying exception handling in a coroutine
Example 16-8. coro_exc_demo.py：学习在协程中处理异常的测试代码

```python
class DemoException(Exception):
    """An exception type for the demonstration."""


def demo_exc_handling(): 
    print('-> coroutine started') 
    while True:
        try:
            x = yield
        except DemoException: #1
            print('*** DemoException handled. Continuing...')
        else: #2
            print('-> coroutine received: {!r}'.format(x))
    raise RuntimeError('This line should never run.') #3
```

1. Special handling for DemoException.
    指定DemoException的处理
2. If no exception, display received value. 
    如果没有异常，则显示接收到的值
3. This line will never be executed.
    此行将永远不会被执行

The last line in Example 16-8 is unreachable because the infinite loop can only be aborted with an unhandled exception, and that terminates the coroutine immediately.
Example 16-8的最后一行是无法到达的，因为无限循环只能被无法处理的异常中断以致立刻结束协程。

Normal operation of demo_exc_handling is shown in Example 16-9.
Example 16-9展示了demo_exc_handling的常规操作

Example 16-9. Activating and closing demo_exc_handling without an exception
Example 16-9 不借助异常来对demo_exc_handling进行激活与关闭

```python
>>> exc_coro = demo_exc_handling()
>>> next(exc_coro)
-> coroutine started
>>> exc_coro.send(11)
-> coroutine received: 11
>>> exc_coro.send(22)
-> coroutine received: 22
>>> exc_coro.close()
>>> from inspect import getgeneratorstate 
>>> getgeneratorstate(exc_coro) 'GEN_CLOSED'
```

If the DemoException is thrown into the coroutine, it’s handled and the demo_exc_han dling coroutine continues, as in Example 16-10.
如果DemoException被传入协程，将不会被处理同时demo_exc_handling协程会继续，如16-10

Example 16-10. Throwing DemoException into demo_exc_handling does not break it
16-10 传入的DemoException不会break掉

```python
>>> exc_coro = demo_exc_handling()
>>> next(exc_coro)
-> coroutine started
>>> exc_coro.send(11)
-> coroutine received: 11
>>> exc_coro.throw(DemoException)
*** DemoException handled. Continuing...
>>> getgeneratorstate(exc_coro)
'GEN_SUSPENDED'
```

On the other hand, if an unhandled exception is thrown into the coroutine, it stops— its state becomes 'GEN_CLOSED'. Example 16-11 demonstrates it.
另一方面，如果一个无法处理的协程被传入协程，他会停下——成为'GEN_CLOSED'状态，如16-11示例

Example 16-11. Coroutine terminates if it can’t handle an exception thrown into it
16-11 如果无法处理被传入的异常，协程将终止

```python
>>> exc_coro = demo_exc_handling()
>>> next(exc_coro)
-> coroutine started
>>> exc_coro.send(11)
-> coroutine received: 11
>>> exc_coro.throw(ZeroDivisionError) 
Traceback (most recent call last):
  ...
ZeroDivisionError
>>> getgeneratorstate(exc_coro)
'GEN_CLOSED'
```

If it’s necessary that some cleanup code is run no matter how the coroutine ends, you need to wrap the relevant part of the coroutine body in a try/finally block, as in Example 16-12.
如果无论协程如何结束都有一些清理代码运行，你需要去在协程的try/finally模块中包装这相关的部分，如16-12。

Example 16-12. coro_finally_demo.py: use of try/finally to perform actions on coroutine termination
16-12 coro_finally_demo.py：使用try/finally去执行终止协程的操作

```python
class DemoException(Exception):
    """An exception type for the demonstration."""

    
def demo_finally():
    print('-> coroutine started') 
    try:
        while True:
            try:
                x = yield
            except DemoException:
                print('*** DemoException handled. Continuing...') 
            else:
                print('-> coroutine received: {!r}'.format(x))
    finally:
        print('-> coroutine ending')
```

One of the main reasons why the yield from construct was added to Python 3.3 has to do with throwing exceptions into nested coroutines. The other reason was to enable coroutines to return values more conveniently. Read on to see how.
Python3.3引入了yield from结构的主要原因之一与把异常传入内嵌的协程有关。另一个原因是令协程更方便地返回值。Read on to see how

## Returning a Value from a Coroutine
## 让协程中返回值
Example 16-13 shows a variation of the averager coroutine that returns a result. For didactic reasons, it does not yield the running average with each activation. This is to emphasize that some coroutines do not yield anything interesting, but are designed to return a value at the end, often the result of some accumulation.
16-13展示了一个不同版本的average协程，将会返回结果。为了说明如何返回值，每次激活协程时不会产出移动平均值。这样做是为了强调一些协程不会产出任何值，而是在结束的时候返回一个值——通常是汇集后的结果。

The result returned by averager in Example 16-13 is a namedtuple with the number of terms averaged (count) and the average. I could have returned just the average value, but returning a tuple exposes another interesting piece of data that was accumulated: the count of terms.
16-3中的averager返回的结果是一个命名元组namedtuple，包含平均的项数和平均值。我可以只返回平均值，但是返回一个元组会暴露出累计数据中另一个有趣的部分：项数。

Example 16-13. coroaverager2.py: code for an averager coroutine that returns a result
16-3 coroaverager2.py：只返回一个结果的averager协程代码

```python
from collections import namedtuple


Result = namedtuple('Result', 'count average')


def averager(): 
    total = 0.0
    count = 0 
    average = None 
    while True:
        term = yield
        if term is None:
            break   #1
        total += term
        count += 1
        average = total/count
    return Result(count, average) #2
```

1. In order to return a value, a coroutine must terminate normally; this is why this
version of averager has a condition to break out of its accumulating loop. 
    为了返回一个value，协程必须正常结束；这是这版averager有从累计循环中break出来情况的原因。

2. Return a namedtuple with the count and average. Before Python 3.3, it was a
syntax error to return a value in a generator function.
    返回一个包含数量与平均数的namedtuple。在Python3.3之前，在生成器函数中返回一个值会有语法错误。

To see how this new averager works, we can drive it from the console, as in Example 16-14.
can can新的averager是如何工作的，我们可以从控制台操作他，如16-14

Example 16-14. coroaverager2.py: doctest showing the behavior of averager
16-14 coroaverager2.py：展示averager的行为

```python
>>> coro_avg = averager()
>>> next(coro_avg)
>>> coro_avg.send(10) #1
>>> coro_avg.send(30)
>>> coro_avg.send(6.5)
>>> coro_avg.send(None) #2
Traceback (most recent call last):
    ...
StopIteration: Result(count=3, average=15.5)
```

1. This version does not yield values.
    这一版不产出值
2. Sending None terminates the loop, causing the coroutine to end by returning the result. As usual, the generator object raises StopIteration. The value attribute of the exception carries the value returned.
    发送None终止循环，通过返回结果导致协程结束。一如既往，生成器对象抛出了StopIteration。异常的value熟悉保存了返回值。

Note that the value of the return expression is smuggled to the caller as an attribute of the StopIteration exception. This is a bit of a hack, but it preserves the existing behavior of generator objects: raising StopIteration when exhausted.
注意，retrun表达式返回的值会被偷偷传递给调用者——作为StopIteration异常的一个属性。这是一个小hack，但这保留了生成器对象的常规行为：
当耗尽时抛出StopIteration

Example 16-15 shows how to retrieve the value returned by the coroutine. 
16-15展示如何收回该协程返回的值

Example 16-15. Catching StopIteration lets us get the value returned by averager
16-15 捕捉StopIteration，获取averager返回的值

```python
>>> coro_avg = averager() 
>>> next(coro_avg)
>>> coro_avg.send(10) 
>>> coro_avg.send(30) 
>>> coro_avg.send(6.5) 
>>> try:
...     coro_avg.send(None)
... except StopIteration as exc: 
...     result = exc.value
...
>>> result
Result(count=3, average=15.5)
```

This roundabout way of getting the return value from a coroutine makes more sense when we realize it was defined as part of PEP 380, and the yield from construct handles it automatically by catching StopIteration internally. This is analogous to the use of StopIteration in for loops: the exception is handled by the loop machinery in a way that is transparent to the user. In the case of yield from, the interpreter not only con‐ sumes the StopIteration, but its value attribute becomes the value of the yield from expression itself. Unfortunately we can’t test this interactively in the console, because it’s a syntax error to use yield from—or yield, for that matter—outside of a function.[4]
这种绕圈子获取协程返回值的行为有许多意义——尤其是当我们认识到这是PEP 380定义的一部分的时候：yield from结构在内部自动处理了捕获到的StopIteration。这和for循环中的StopIteration用法很相似：循环机制处理异常的方式很容易被使用者理解。以yield from来讲，解释器不仅捕捉StopIteration，而且他的value属性变成yield from表达式自己的value。不幸的是我们不能在控制台进行交互的测试，因为在函数外部使用yield from或是yield会造成语法错误。[4]

[Note4]There is an iPython extension called ipython-yf that enables evaluating yield from directly in the iPython console. It’s used to test asynchronous code and works with asyncio. It was submitted as a patch to Python 3.5 but was not accepted. See Issue #22412: Towards an asyncio-enabled command line in the Python bug tracker.
[注4]这是一个叫做ipython-yf的iPython延伸，这可以支持在ipython控制台中直接计算yield from。这被用于测试异步代码同时与asyncio一起使用。他被作为一个补丁提交至Python3.5中，但没有被接受。可见Issue #22412：Python bug追踪——支持asyncio的命令行

The next section has an example where the averager coroutine is used with yield from to produce a result, as intended in PEP 380. So let’s tackle yield from.
下一节会举例：以PEP 380定义的方式使用yield from结构的averager协程去生成一个值。接下来讨论yield from。

## Using yield from
## 使用yield from
The first thing to know about yield from is that it is a completely new language construct. It does so much more than yield that the reuse of that keyword is arguably misleading. Similar constructs in other languages are called await, and that is a much better name because it conveys a crucial point: when a generator gen calls yield from subgen(), the subgen takes over and will yield values to the caller of gen; the caller will in effect drive subgen directly. Meanwhile gen will be blocked, waiting until subgen terminates.[5]
首先我们要认识到yield from完全是一种新的语言结构。yield from的作用比yield要多得多，以至于重复使用那个关键词会造成误导。其他语言中的类似结构被称为await，这确实是一个更好的名字，因为他表达出了一个关键点：当一个生成器gen调用了yield from subgen()，subgen接收并将产出值传递给gen的调用方；即调用方实际上直接控制subgen。同时gen将被阻塞，一直等待直到subgen终止。[5]

[Note5]As I write this, there is an open PEP proposing the addition of await and async keywords: PEP 492 — Coroutines with async and await syntax.
[注5]当我写到这里，有一个正在进行的PEP提议“新增await和async关键词”： Coroutines with async and await syntax。

We’ve seen in Chapter 14 that yield from can be used as a shortcut to yield in a for loop. For example, this:
我们在14章说过yield from可以被用作在for循环中简化yield的方式，如：

```python
>>> def gen():
...     for c in 'AB':
...         yield c
...     for i in range(1, 3):
...         yield i
... 
>>> list(gen())
['A', 'B', 1, 2]
```

Can be written as: 

```python
>>> def gen():
... yield from 'AB'
... yield from range(1, 3) 
...
>>> list(gen())
['A', 'B', 1, 2]
```

When we first mentioned yield from in “New Syntax in Python 3.3: yield from” on page 433, the code from Example 16-16 demonstrates a practical use for it.[6]
当我们在433页“Python 3.3新语法：yield from”中首次提及yield from时，16-16的代码演示了这个结构的6-16用法。

[Note6]Example 16-16 is a didactic example only. The itertools module already provides an optimized chain function written in C.
[注6]16-16只是一个教学示例。itertools模块已经提供了由C编写的优化版chain函数。

Example 16-16. Chaining iterables with yield from

```python
>>> def chain(*iterables): 
...     for it in iterables: 
...         yield from it 
...
>>> s = 'ABC'
>>> t = tuple(range(3)) 
>>> list(chain(s, t)) 
['A', 'B', 'C', 0, 1, 2]
```

A slightly more complicated—but more useful—example of yield from is in “Recipe 4.14. Flattening a Nested Sequence” in Beazley and Jones’s Python Cookbook, 3E (source code available on GitHub).
一个稍微复杂些单更加有用的yield from示例，在Beazley和Jones的Python Cookbook一书的第三版中“4.14 扁平化一个嵌套序列”章节（Github中有源码）

The first thing the yield from x expression does with the x object is to call iter(x) to obtain an iterator from it. This means that x can be any iterable.
"yield from x"表达式对x对象做的第一件事 是去调用iter(x)以获得他的迭代器。这意味着x可以是任何可迭代对象。

However, if replacing nested for loops yielding values was the only contribution of yield from, this language addition wouldn’t have had a good chance of being accepted. The real nature of yield from cannot be demonstrated with simple iterables; it requires the mind-expanding use of nested generators. That’s why PEP 380, which introduced yield from, is titled “Syntax for Delegating to a Subgenerator.”
但是如果替换内嵌for循环产出值是yield from仅有的贡献的话，这种语言扩充将不会有什么机会被Python接受。yield from 真正的特质不能通过简单的可迭代对象演示出来；他需要使用内嵌生成器来扩展思维。这就是为什么PEP 380在介绍yield from的标题取为“委托给一个子生成器的语法”。

The main feature of yield from is to open a bidirectional channel from the outermost caller to the innermost subgenerator, so that values can be sent and yielded back and forth directly from them, and exceptions can be thrown all the way in without adding a lot of exception handling boilerplate code in the intermediate coroutines. This is what enables coroutine delegation in a way that was not possible before.
yield from的主要特点是 从最外层调用者到最内层的子生成器之间打开一条双向通道，以便value可以直接从他们那里send和yield返回，并且异常可以自始至终被抛出，同时无需在中间的协程中添加任何异常处理样板代码。这就是以一种以前不可能的方式实现协程委托的原因。

The use of yield from requires a nontrivial arrangement of code. To talk about the required moving parts, PEP 380 uses some terms in a very specific way:
使用yield from需要重要的代码安排。为了讨论所需更改的部分，PEP 380使用了一些特定的术语：

- delegating generator
    The generator function that contains the `yield from <iterable>` expression.
    包含`yield from <iterable>`表达式的生成器函数。

- subgenerator
    The generator obtained from the `<iterable>` part of the yield from expression. This is the “subgenerator” mentioned in the title of PEP 380: “Syntax for Delegating to a Subgenerator.”
    从yield from表达式的`<iterable>`部分获得到的生成器。这就是PEP 380标题（Syntax for Delegating to a Subgenerator）提及的“subgenerator”。

- caller
    PEP 380 uses the term “caller” to refer to the client code that calls the delegating generator. Depending on context, I use “client” instead of “caller,” to distinguish from the delegating generator, which is also a “caller” (it calls the subgenerator).
    PEP 380使用术语“caller”去指代调用delegating generator的客户代码。依赖此背景，我用“client”而不是“caller”去区别那些也被成为“caller”的delegating generator（他实际调用的是subgenerator）。

>###Note
>PEP 380 often uses the word “iterator” to refer to the subgenerator. That’s confusing because the delegating generator is also an iterator. So I prefer to use the term subgenerator, in line with the title of the PEP—“Syntax for Delegating to a Subgenerator.” However, the subgenerator can be a simple iterator implementing only `__next__`, and yield from can handle that too, although it was created to support generators implementing `__next__,` send, close, and throw.
>PEP 380经常使用单词“iterator”去指代subgenerator。这很容易令人迷惑，因为delegating generator也是一个iterator。所以我更喜欢用“subgenerator”，这与PEP的标题“Syntax for Delegating to a Subgenerator”一致。然而，subgeneratro可以是一个只实现`__next__`的简单生成器，yield from同样可以处理，虽然创建他是为了支持生成器实现`__next__`，send，close和throw。

Example 16-17 provides more context to see yield from at work, and Figure 16-2 identifies the relevant parts of the example.[7]
16-17提供了yield from工作时的更多上下文，图示16-2标识了该示例的相关部分。[7]

[Note7]The picture in Figure 16-2 was inspired by a diagram by Paul Sokolovsky.
[注7]图示16-2中的图片灵感来源于Paul Sokolovsky的一个图表。

![image](images/c16_2.png)

Figure 16-2. While the delegating generator is suspended at yield from, the caller sends data directly to the subgenerator, which yields data back to the caller. The delegating generator resumes when the subgenerator returns and the interpreter raises StopIteration with the returned value attached.
图示16-2 当delegating generator在yield from处暂停时，caller直接发送数据到subgenerator，他也产回数据到caller。当subgenerator返回并且解释器抛出带有附加返回值的StopIteration时，delegating generator将恢复。

The coroaverager3.py script reads a dict with weights and heights from girls and boys in an imaginary seventh grade class. For example, the key 'boys;m' maps to the heights of 9 boys, in meters; 'girls;kg' are the weights of 10 girls in kilograms. The script feeds the data for each group into the averager coroutine we’ve seen before, and produces a report like this one:
coroaverager3.py脚本虚构了一个七年级班级，将孩子们的身高体重汇总到一个字典中。例如，key'boys;m'对应到9个男孩的身高（米）；'girls;kg'则是10个女孩的体重（公斤）。该脚本将每组数据推送至我们之前见到的averager协程中，并产生了如下的报告：

```shell
$ python3 coroaverager3.py
    9 boys  averaging 40.42kg
    9 boys  averaging 1.39m
    10 girls averaging 42.04kg
    10 girls averaging 1.43m
```

The code in Example 16-17 is certainly not the most straightforward solution to the problem, but it serves to show yield from in action. This example is inspired by the one given in What’s New in Python 3.3.
16-17的代码当然不是这个问题最直接的解决方式，但他有助于展示yield from的操作。这个示例灵感来源于Python 3.3新增内容。

Example 16-17. coroaverager3.py: using yield from to drive averager and report statistics
16-17 coroaverager3.py：使用yield from操作averager并报告统计值

```python
from collections import namedtuple

Result = namedtuple('Result', 'count average')


# the subgenerator
def averager(): #1
    total = 0.0
    count = 0 
    average = None 
    while True:
        term = yield #2
        if term is None: #3
            break
        total += term
        count += 1
        average = total/count
    return Result(count, average) #4


# the delegating generator
def grouper(results, key): #5
    while True: #6
        results[key] = yield from averager() #7


# the client code, a.k.a. the caller
def main(data): #8
    results = {}
    for key, values in data.items(): 
        group = grouper(results, key) #9
        next(group) #10
        for value in values:
            group.send(value) #11
            group.send(None) # important! #12

    
    # print(results)  # uncomment to debug
    report(results) 


# output report
def report(results):
    for key, result in sorted(results.items()):
        group, unit = key.split(';')
        print('{:2} {:5} averaging {:.2f}{}'.format(
              result.count, group, result.average, unit))


data={ 'girls;kg':
        [40.9, 38.5, 44.3, 42.2, 45.2, 41.7, 44.5, 38.0, 40.6, 44.5],
    'girls;m':
        [1.6, 1.51, 1.4, 1.3, 1.41, 1.39, 1.33, 1.46, 1.45, 1.43],
    'boys;kg':
        [39.0, 40.8, 43.2, 40.8, 43.1, 38.6, 41.4, 40.6, 36.3],
    'boys;m':
        [1.38, 1.5, 1.32, 1.25, 1.37, 1.48, 1.25, 1.49, 1.46],
}

if __name__ == '__main__':
    main(data)
```

1. Same `averager` coroutine from Example 16-13. Here it is the subgenerator.   
    和16-13一样的`averager`协程，这里作为subgenerator。
2. Each value sent by the client code in `main` will be bound to `term` here.  
    从client代码`main`发送过来的value一定会到`term`这里。
3. The crucial terminating condition. Without it, a `yield from` calling this coroutine will block forever.  
    关键的终止条件。如果没有这句，`yield from`调用该协程将永远阻塞。
4. The returned `Result` will be the value of the `yield from` expression in `grouper`.  
    返回的`Result`将成为`grouper`中`yield from`表达式的值。
5. `grouper` is the delegating generator.  
    `grouper`是delegating generator。
6. Each iteration in this loop creates a new instance of averager; each is a generator object operating as a coroutine.  
    这个循环中的每次迭代会创建一个新的averager实例；每个实例都是一个生成器对象并作为协程使用。
7. Whenever `grouper` is sent a value, it’s piped into the `averager` instance by the `yield from`. `grouper` will be suspended here as long as the averager instance is consuming values sent by the client. When an averager instance runs to the end, the value it returns is bound to `results[key]`. The while loop then proceeds to create another averager instance to consume more values.  
    无论何时，`grouper`一旦被sent了值，他都会被`yield from`传送到`averager`实例中。只要averager实例正在处理来自client的值的时候，`grouper`都将被暂停在这里。当一个averager实例运行至结尾，他返回的值会被绑定至`result[key]`。
8. main is the client code, or “caller” in PEP 380 parlance. This is the function that drives everything.  
    main是客户代码或PEP 380说法中的"caller"。这是驱动一切的函数。
9. group is a generator object resulting from calling grouper with the results dict to collect the results, and a particular key. It will operate as a coroutine.  
    group是一个生成器对象，其结果来自于调用grouper（传入一个用于收集结果的results字典和一个特定key）。这将被作为一个协程来操作。
10. Prime the coroutine.  
    激活协程。
11. Send each value into the grouper. That value ends up in the `term = yield` line of `averager`; `grouper` never has a chance to see it.  
    Send每一个值到grouper。这个值最终会到达`averager`的`term = yield`这行；而`grouper`永远不知道传入的是什么。
12. Sending None into `grouper` causes the current `averager` instance to terminate, and allows grouper to run again, which creates another `averager` for the next group of values.  
    将None Send进grouper导致当前的`averager`实例终止，同时允许grouper再一次运行——为下一组value创建另一个`averager`。

The last callout in Example 16-17 with the comment "important!" highlights a crucial line of code: group.send(None), which terminates one averager and starts the next. If you comment out that line, the script produces no output. Uncommenting the print(results) line near the end of main reveals that the results dict ends up empty.  
16-17中最后一个编号#12使用“important!”重点标明了决定性的一行代码：group.send(None)，这一行终止了一个averager，同时启动了下一个averager。如果你注释掉了这行，脚本将不会有任何输出。此时取消掉main结尾附近的“print(results)”显示results字典最终为空。

>####Note
>If you want to figure out for yourself why no results are collected, it will be a great way to exercise your understanding of how yield from works. The code for coroaverager3.py is in the Fluent Python code repository. The explanation is next.  
>如果你想搞清楚为什么没有收集到results，这样可以很好地理解yield from如何工作。coroaverager3.py的代码在Fluent Python代码库中，接下来是解释。

Here is an overview of how Example 16-17 works, explaining what would happen if we omitted the call group.send(None) marked “important!” in main:
这里是关于16-17如何运行的概述，解释了如果省去了group.send(None)（在main中标注了"important!"的那句）将会发生什么。

- Each iteration of the outer for loop creates a new grouper instance named group; this is the delegating generator.  
    外部for循环的每一次迭代创建了名为group的grouper实例；这就是delegating generator。

- The call next(group) primes the grouper delegating generator, which enters its while True loop and suspends at the yield from, after calling the subgenerator averager.  
    调用next(group)激活了grouper delegating generator，在调用了subgenerator averager后，进入到while True循环并暂停在yield from位置。

- The inner for loop calls group.send(value); this feeds the subgenerator averager directly. Meanwhile, the current group instance of grouper is suspended at the yield from.  
    内部的for循环调用了group.send(value)；这一操作直接将值发送给了subgenerator averager。同时当前的group暂停在yield from位置。

- When the inner for loop ends, the group instance is still suspended at the yield from, so the assignment to results[key] in the body of grouper has not happened yet.  
    当内层for循环结束，group实例仍然暂停在yield from，所以在grouper中为results[key]赋值行为还没有发生。

- Without the last group.send(None) in the outer for loop, the averager subgenerator never terminates, the delegating generator group is never reactivated, and the assignment to results[key] never happens.  
    如果外层for循环中没有最后一步的group.send(None)，subgenerator "averager"将不会终止，delegating generator "group"将不会重新运行，并且赋值results[key]的行为也不会发生。

- When execution loops back to the top of the outer for loop, a new grouper instance is created and bound to group. The previous grouper instance is garbage collected (together with its own unfinished averager subgenerator instance).  
    当循环执行回外层for循环的顶部时，会创建一个新的grouper实例并绑定至group。而之前的grouper实例则被垃圾回收（同时被处理的还有他其中未结束的averager实例）。

>####Catious
>The key takeaway from this experiment is: if a subgenerator never terminates, the delegating generator will be suspended forever at the yield from. This will not prevent your program from making progress because the yield from (like the simple yield) transfers control to the client code (i.e., the caller of the delegating generator). But it does mean that some task will be left unfinished.  
>该实验的关键点是：如果一个subgenerator永不终止，那么delegating generator将永远被暂停在yield from处。这不会阻止你的程序继续下去，因为yield from（像简单的yield）将控制流传递至client代码（如delegating generator的调用者）。但是这也意味着一些task将无法完成。

Example 16-17 demonstrates the simplest arrangement of yield from, with only one delegating generator and one subgenerator. Because the delegating generator works as a pipe, you can connect any number of them in a pipeline: one delegating generator uses yield from to call a subgenerator, which itself is a delegating generator calling another subgenerator with yield from, and so on. Eventually this chain must end in a simple generator that uses just yield, but it may also end in any iterable object, as in Example 16-16.  
    16-17演示了yield from最简单的排列，只用了一个delegating generator和一个subgenerator。由于delegating generator的作用像是一个管道，你可以用一个pipeline连接多个：一个delegating generator使用yield from调用一个subgenerator，而该subgenerator也是一个使用yield from调用其它subgenerator的delegating generator，以此类推。当然这条“generator链”最终会以一个只用了yield的简单generator作为结尾，但他也可能在任何可迭代对象中结束，如16-16所示。

Every yield from chain must be driven by a client that calls `next(...)` or `.send(...) `on the outermost delegating generator. This call may be implicit, such as a for loop.  
    每一条yield from链必定被一个client驱动，这个client在最外层的delegating generator上调用`next(...)`或`send(...)`。这种调用可能是隐式的，如for循环。

Now let’s review the formal description of the yield from construct, as presented in PEP 380.  
    现在我们来回顾一下PEP 380中介绍的yield from结构的正式描述。

## The Meaning of yield from
## yield from的意义
While developing PEP 380, Greg Ewing—the author—was questioned about the complexity of the proposed semantics. One of his answers was “For humans, almost all the important information is contained in one paragraph near the top.” He then quoted part of the draft of PEP 380 which at the time read as follows:
在PEP 380撰写时，作者Greg Ewing被质疑其提出语法的复杂性。他的回答之一是“对人类来讲，几乎所有重要信息都包含在靠近顶部的段落中。”然后他引用了PEP 380草案的部分内容，当时的案文如下：

    “When the iterator is another generator, the effect is the same as if the body of the subgenerator were inlined at the point of the yield from expression. Furthermore, the subgenerator is allowed to execute a return statement with a value, and that value becomes the value of the yield from expression.”[8]

    [Note8]Message to Python-Dev: “PEP 380 (yield from a subgenerator) comments” (March 21, 2009).  

    “当迭代器是另一个生成器时，其效果类似于subgenerator的皮囊内联在yield from表达式的点。此外，subgenerator被允许去执行一句带有value的return语句，然后这个value将成为yield from表达式的value。”[8]

Those soothing words are no longer part of the PEP—because they don’t cover all the corner cases. But they are OK as a first approximation.  
    那些安慰的话不再是PEP中一部分——因为他们不能cover所有细微的case，但是作为第一近似仍然是OK的。

The approved version of PEP 380 explains the behavior of yield from in six points in the Proposal section. I reproduce them almost exactly here, except that I replaced every occurrence of the ambiguous word “iterator” with “subgenerator” and added a few clarifications. Example 16-17 illustrates these four points:  
    正式版的PEP 380在提案部分用6点解释了yield from的行为。我这里几乎完全复制了他们，除了我将有歧义的“iterator”替换成了“subgenerator”并添加了一点点阐述。16-17阐明了以下四点：

- Any values that the subgenerator yields are passed directly to the caller of the delegating generator (i.e., the client code).  
    subgenerator yield出的任何value都被直接传递到delegating generator的调用者（如client代码）。

- Any values sent to the delegating generator using send() are passed directly to the subgenerator. If the sent value is None, the subgenerator’s __next__() method is called. If the sent value is not None, the subgenerator’s send() method is called. If the call raises StopIteration, the delegating generator is resumed. Any other exception is propagated to the delegating generator.  
    delegating generator使用send()发送的任何value都被直接传递到subgenerator。如果send的value是None，这会调用到subgenerator的__next__()方法。如果不是None，会调用到subgenerator的send()方法。如果本次调用引发了StopIteration，将恢复delegating generator。任何其他的异常都而被传播到delegating generator。

- return expr in a generator (or subgenerator) causes StopIteration(expr) to be raised upon exit from the generator.  
    在generator（或subgenerator）中返回expr会导致在generator结束时引发StopIteration(expr)。

- The value of the yield from expression is the first argument to the StopIteration exception raised by the subgenerator when it terminates.  
    yield from表达式的value是StopIteration异常（在结束时引发）的第一个参数。

The other two features of yield from have to do with exceptions and termination:
    yield from的另外两个特点与exception和termination有关：

- Exceptions other than GeneratorExit thrown into the delegating generator are passed to the throw() method of the subgenerator. If the call raises StopIteration, the delegating generator is resumed. Any other exception is propagated to the delegating generator.
    除GeneratorExit以外的Exception，会通过subgenerator的throw()方法，传递至delegating generator。如果本次调用引发了StopIteration，会恢复delegating generator，而其他的异常会传播到delegating generator。

- If a GeneratorExit exception is thrown into the delegating generator, or the close() method of the delegating generator is called, then the close() method of the subgenerator is called if it has one. If this call results in an exception, it is propagated to the delegating generator. Otherwise, GeneratorExit is raised in the delegating generator.  
    如果将GeneratorExit异常抛给delegating generator，或是调用了delegating generator的close()方法，那么也将调用subgenerator的close()——如果有的话。如果本次调用的结果是一个异常，这会传递给delegating generatroe。否则delegating generator中将引发GeneratorExit。

The detailed semantics of yield from are subtle, especially the points dealing with exceptions. Greg Ewing did a great job putting them to words in English in PEP 380.  
    yield from的详细语义很隐晦，尤其是处理异常这部分。Greg Ewing做了件很棒的事情：在PEP 380中把它译成了英文单词。

Ewing also documented the behavior of yield from using pseudocode (with Python syntax). I personally found it useful to spend some time studying the pseudocode in PEP 380. However, the pseudocode is 40 lines long and not so easy to grasp at first.  
    Ewing也通过伪代码（结合Python语法）将yield from的行为记录下来。我个人认为花些时间研究PEP 380中的伪代码是很有用的。但是伪代码有40行并且不是一开始就很容易理解。

A good way to approach that pseudocode is to simplify it to handle only the most basic and common use case of `yield from`.  
    处理伪代码的方法是简化他，让他只处理最基础和通用的``yield from`用例。

Consider that yield from appears in a delegating generator. The client code drives delegating generator, which drives the subgenerator. So, to simplify the logic involved, let’s pretend the client doesn’t ever call .throw(...) or .close() on the delegating generator. Let’s also pretend the subgenerator never raises an exception until it terminates, when StopIteration is raised by the interpreter.  
    考虑到yield from是在delegating generator中用到，而client代码驱动着delegating generator，delegating generator驱动着subgenerator。所以为了简化其中的逻辑，我们假装client永不会在delegeting generator上调用.throw()或.close()，同时假装当解释器引发StopIteration时，subgenerator直到终止也永远不会引发异常。

Example 16-17 is a script where those simplifying assumptions hold. In fact, in much real-life code, the delegating generator is expected to run to completion. So let’s see how yield from works in this happier, simpler world.  
16-17是上述假设成立的脚本。而事实上许多现实生活中的代码，是期望delegating generator运行至结束的。所以我们来看在这种更happy更simple的情况下，yield from是如何工作的。

Take a look at Example 16-18, which is an expansion of this single statement, in the body of the delegating generator:  
    来看作为这条语句的扩展的16-18，在delegating generator的体内：

```python
RESULT = yield from EXPR
```

Try to follow the logic in Example 16-18.  
    尝试沿着16-18的逻辑。

Example 16-18. Simplified pseudocode equivalent to the statement RESULT = yield from EXPR in the delegating generator (this covers the simplest case: .throw(...) and .close() are not supported; the only exception handled is StopIteration)  
    16-18。简化的伪代码相当于delegating generator中的语句"RESULT = yield from EXPR"（这包含了最简单的case: 未支持.throw()和.close()，仅处理了StopIteration）。

```python
_i = iter(EXPR) #1


try:
    _y = next(_i) #2
except StopIteration as _e:
    _r = _e.value #3
else:
    while 1: #4
        _s = yield _y #5
    try:
        _y = _i.send(_s) #6
    except StopIteration as _e: #7
        _r = _e.value
        break


RESULT = _r #8
```

1. The `EXPR` can be any iterable, because iter() is applied to get an iterator _i (this
is the subgenerator).  
    `EXPR`可以是任何可迭代对象，因为iter()被用于去获取一个迭代器_i（这是一个subgenerator）。
2. The subgenerator is primed; the result is stored to be the first yielded value _y.  
    激活subgenerator；产出的第一个value，作为结果保存在_y。
3. If StopIteration was raised, extract the value attribute from the exception and assign it to _r: this is the RESULT in the simplest case.  
    如果raise了StopIteration，那么从这个异常中提取value熟悉并赋值给_r：这就是这个最简化case的RESULT。
4. While this loop is running, the delegating generator is blocked, operating just as a channel between the caller and the subgenerator.  
    当该loop运行阶段，delegating generator一直阻塞，仅作为caller和subgenerator中的一条通路。
5. Yield the current item yielded from the subgenerator; wait for a value _s sent by the caller. Note that this is the only yield in this listing.  
    产出subgenerator产出的当前项；
6. Try to advance the subgenerator, forwarding the _s sent by the caller.
7. If the subgenerator raised StopIteration, get the value, assign to _r, and exit
the loop, resuming the delegating generator.
8. _r is the RESULT: the value of the whole yield from expression.

In this simplified pseudocode, I preserved the variable names used in the pseudocode published in PEP 380. The variables are:

- `_i (iterator)`
    The subgenerator
- `_y (yielded)`
    A value yielded from the subgenerator
- `_r (result)`
    The eventual result (i.e., the value of the yield from expression when the subgen‐ erator ends)
- `_s (sent)`
    A value sent by the caller to the delegating generator, which is forwarded to the subgenerator
- `_e (exception)`
    An exception (always an instance of StopIteration in this simplified pseudocode)

Besides not handling .throw(...) and .close(), the simplified pseudocode always uses .send(...) to forward next() or .send(...) calls by the client to the subgenerator. Don’t worry about these fine distinctions on a first reading. As mentioned, Example 16-17 would run perfectly well if the yield from did only what is shown in the simplified pseudocode in Example 16-18.

But the reality is more complicated, because of the need to handle .throw(...) and .close() calls from the client, which must be passed into the subgenerator. Also, the subgenerator may be a plain iterator that does not support .throw(...) or .close(), so this must be handled by the yield from logic. If the subgenerator does implement those methods, inside the subgenerator both methods cause exceptions to be raised, which must be handled by the yield from machinery as well. The subgenerator may also throw exceptions of its own, unprovoked by the caller, and this must also be dealt with in the yield from implementation. Finally, as an optimization, if the caller calls next(...) or .send(None), both are forwarded as a next(...) call on the subgenerator; only if the caller sends a non-None value, the .send(...) method of the subgenerator is used.

For your convenience, following is the complete pseudocode of the yield from expan‐ sion from PEP 380, syntax-highlighted and annotated. Example 16-19 was copied ver‐ batim; only the callout numbers were added by me.

Again, the code shown in Example 16-19 is an expansion of this single statement, in the body of the delegating generator:

```python
RESULT = yield from EXPR
```

Example 16-19. Pseudocode equivalent to the statement RESULT = yield from EXPR in the delegating generator

```python
_i = iter(EXPR) #1
try:
    _y = next(_i) #2
except StopIteration as _e:
    _r = _e.value #3
else:
    while 1: #4
        try:
            _s = yield _y #5
        except GeneratorExit as _e: #6
            try:
                _m = _i.close
            except AttributeError: 
                pass
            else: 
                _m()
            raise _e
        except BaseException as _e: #7
            _x = sys.exc_info() 
            try:
                _m = _i.throw 
            except AttributeError:
                raise _e 
            else: #8
                try:
                    _y = _m(*_x)
                except StopIteration as _e: 
                    _r = _e.value
                    break 
        else: #9
            try: #10
                if _s is None: #11
                    _y = next(_i) 
                else:
                    _y = _i.send(_s) 
            except StopIteration as _e: #12
                _r = _e.value 
                break

RESULT = _r #13
```

1. The EXPR can be any iterable, because iter() is applied to get an iterator _i (this
is the subgenerator).
2. The subgenerator is primed; the result is stored to be the first yielded value _y.
3. If StopIteration was raised, extract the value attribute from the exception and assign it to _r: this is the RESULT in the simplest case.
4. While this loop is running, the delegating generator is blocked, operating just as a channel between the caller and the subgenerator.
5. Yield the current item yielded from the subgenerator; wait for a value _s sent by the caller. This is the only yield in this listing.
6. This deals with closing the delegating generator and the subgenerator. Because the subgenerator can be any iterator, it may not have a close method.
7. This deals with exceptions thrown in by the caller using .throw(...). Again, the subgenerator may be an iterator with no throw method to be called—in which case the exception is raised in the delegating generator.
8. If the subgenerator has a throw method, call it with the exception passed from the caller. The subgenerator may handle the exception (and the loop continues); it may raise StopIteration (the _r result is extracted from it, and the loop ends); or it may raise the same or another exception, which is not handled here and propagates to the delegating generator.
9. If no exception was received when yielding... 
10. Try to advance the subgenerator...
11. Call next on the subgenerator if the last value received from the caller was None, otherwise call send.
12. If the subgenerator raised StopIteration, get the value, assign to _r, and exit the loop, resuming the delegating generator.
13. _r is the RESULT: the value of the whole yield from expression.

Most of the logic of the yield from pseudocode is implemented in six try/except blocks nested up to four levels deep, so it’s a bit hard to read. The only other control flow keywords used are one while, one if, and one yield. Find the while, the yield, the next(...), and the .send(...) calls: they will help you get an idea of how the whole structure works.

Right at the top of Example 16-19, one important detail revealed by the pseudocode is that the subgenerator is primed (second callout in Example 16-19).[9] This means that auto-priming decorators such as that in “Decorators for Coroutine Priming” on page 469 are incompatible with yield from.

[9]9. In a message to Python-ideas on April 5, 2009, Nick Coghlan questioned whether the implicit priming done by yield from was a good idea.

In the same message I quoted in the opening of this section, Greg Ewing has this to say about the pseudocode expansion of yield from:

    You’re not meant to learn about it by reading the expansion—that’s only there to pin down all the details for language lawyers.


Focusing on the details of the pseudocode expansion may not be helpful—depending on your learning style. Studying real code that uses yield from is certainly more prof‐ itable than poring over the pseudocode of its implementation. However, almost all the yield from examples I’ve seen are tied to asynchronous programming with the asyn cio module, so they depend on an active event loop to work. We’ll see yield from numerous times in Chapter 18. There are a few links in “Further Reading” on page 500 to interesting code using yield from without an event loop.

We’ll now move on to a classic example of coroutine usage: programming simulations. This example does not showcase yield from, but it does reveal how coroutines are used to manage concurrent activities on a single thread.

## Use Case: Coroutines for Discrete Event Simulation
Coroutines are a natural way of expressing many algorithms, such as simulations, games, asynchronous I/O, and other forms of event-driven programming or co-operative mul‐ titasking.[10]
— Guido van Rossum and Phillip J. Eby
PEP 342—Coroutines via Enhanced Generators

[10]10. Opening sentence of the “Motivation” section in PEP 342.

In this section, I will describe a very simple simulation implemented using just corou‐ tines and standard library objects. Simulation is a classic application of coroutines in the computer science literature. Simula, the first OO language, introduced the concept of coroutines precisely to support simulations.

>#### Tips
>The motivation for the following simulation example is not aca‐ demic. Coroutines are the fundamental building block of the asyncio package. A simulation shows how to implement concur‐ rent activities using coroutines instead of threads—and this will greatly help when we tackle asyncio with in Chapter 18.

Before going into the example, a word about simulations.

### About Discrete Event Simulations
A discrete event simulation (DES) is a type of simulation where a system is modeled as a sequence of events. In a DES, the simulation “clock” does not advance by fixed incre‐ ments, but advances directly to the simulated time of the next modeled event. For ex‐ ample, if we are simulating the operation of a taxi cab from a high-level perspective, one event is picking up a passenger, the next is dropping the passenger off. It doesn’t matter if a trip takes 5 or 50 minutes: when the drop off event happens, the clock is updated to the end time of the trip in a single operation. In a DES, we can simulate a year of cab trips in less than a second. This is in contrast to a continuous simulation where the clock advances continuously by a fixed—and usually small—increment.

Intuitively, turn-based games are examples of discrete event simulations: the state of the game only changes when a player moves, and while a player is deciding the next move, the simulation clock is frozen. Real-time games, on the other hand, are continuous simulations where the simulation clock is running all the time, the state of the game is updated many times per second, and slow players are at a real disadvantage.

Both types of simulations can be written with multiple threads or a single thread using event-oriented programming techniques such as callbacks or coroutines driven by an event loop. It’s arguably more natural to implement a continuous simulation using threads to account for actions happening in parallel in real time. On the other hand, coroutines offer exactly the right abstraction for writing a DES. SimPy[11] is a DES package for Python that uses one coroutine to represent each process in the simulation.

[11]See the official documentation for Simpy—not to be confused with the well-known but unrelated SymPy, a library for symbolic mathematics.

>#### Tips
>In the field of simulation, the term process refers to the activities of an entity in the model, and not to an OS process. A simulation process may be implemented as an OS process, but usually a thread or a coroutine is used for that purpose.

If you are interested in simulations, SimPy is well worth studying. However, in this section, I will describe a very simple DES implemented using only standard library features. My goal is to help you develop an intuition about programming concurrent actions with coroutines. Understanding the next section will require careful study, but the reward will come as insights on how libraries such as asyncio, Twisted, and Tornado can manage many concurrent activities using a single thread of execution.

### The Taxi Fleet Simulation
In our simulation program, taxi_sim.py, a number of taxi cabs are created. Each will make a fixed number of trips and then go home. A taxi leaves the garage and starts “prowling”—looking for a passenger. This lasts until a passenger is picked up, and a trip starts. When the passenger is dropped off, the taxi goes back to prowling.

The time elapsed during prowls and trips is generated using an exponential distribution. For a cleaner display, times are in whole minutes, but the simulation would work as well using float intervals.12 Each change of state in each cab is reported as an event. 

Figure 16-3 shows a sample run of the program.

![image](images/c16_3.png)

Figure 16-3. Sample run of taxi_sim.py with three taxis. The -s 3 argument sets the random generator seed so program runs can be reproduced for debugging and demon‐ stration. Colored arrows highlight taxi trips.

The most important thing to note in Figure 16-3 is the interleaving of the trips by the three taxis. I manually added the arrows to make it easier to see the taxi trips: each arrow starts when a passenger is picked up and ends when the passenger is dropped off. In‐ tuitively, this demonstrates how coroutines can be used for managing concurrent ac‐ tivities.

Other things to note about Figure 16-3:

• Each taxi leaves the garage 5 minutes after the other.
• It took 2 minutes for taxi 0 to pick up the first passenger at time=2; 3 minutes for taxi 1 (time=8), and 5 minutes for taxi 2 (time=15).
• The cabbie in taxi 0 only makes two trips (purple arrows): the first starts at time=2 and ends at time=18; the second starts at time=28 and ends at time=65—the longest trip in this simulation run.
• Taxi 1 makes four trips (green arrows) then goes home at time=110.
• Taxi 2 makes six trips (red arrows) then goes home at time=109. His last trip lasts
only one minute, starting at time=97.[13]
• While taxi 1 is making her first trip, starting at time=8, taxi 2 leaves the garage at
time=10 and completes two trips (short red arrows).
• In this sample run, all scheduled events completed in the default simulation time
of 180 minutes; last event was at time=110.

[13]I was the passenger. I realized I forgot my wallet.

The simulation may also end with pending events. When that happens, the final message
reads like this:

```
    *** end of simulation time: 3 events pending ***
```

The full listing of taxi_sim.py is at Example A-6. In this chapter, we’ll show only the parts that are relevant to our study of coroutines. The really important functions are only two: taxi_process (a coroutine), and the Simulator.run method where the main loop of the simulation is executed.

Example 16-20 shows the code for taxi_process. This coroutine uses two objects de‐ fined elsewhere: the compute_delay function, which returns a time interval in minutes, and the Event class, a namedtuple defined like this:

```python
    Event = collections.namedtuple('Event', 'time proc action')
```

In an Event instance, time is the simulation time when the event will occur, proc is the
identifier of the taxi process instance, and action is a string describing the activity.

 Let’s review taxi_process play by play in Example 16-20.

Example 16-20. taxi_sim.py: taxi_process coroutine that implements the activities of each taxi

```python
def taxi_process(ident, trips, start_time=0):
"""Yield to simulator issuing event at each state change""" time = yield Event(start_time, ident, 'leave garage')
for i in range(trips):
time = yield Event(time, ident, 'pick up passenger') time = yield Event(time, ident, 'drop off passenger')
yield Event(time, ident, 'going home') # end of taxi process
```